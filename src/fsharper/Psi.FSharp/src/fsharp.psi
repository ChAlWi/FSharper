options { 
  parserPackage="JetBrains.ReSharper.Psi.FSharp.Gen";
  parserClassName="FSharpParserGenerated";
  psiInterfacePackageName="JetBrains.ReSharper.Psi.FSharp.Tree";
  psiStubsPackageName="JetBrains.ReSharper.Psi.FSharp.Impl.Tree";
  psiStubsBaseClass="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpCompositeElement";
  tokenClassName="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpToken";
  tokenTypePrefix="";
  parserTargetSubdir="Parsing/FSharp";
  psiInterfacesTargetSubdir="Psi/FSharp";
  psiStubsTargetSubdir="Psi/FSharp/Impl";
  elementTypePrefix="";
//  semanticVisitorClassName="ElementVisitor";
//  hierarchicalSemanticVisitorClassName="HierarchicalElementVisitor";
  visitorClassName="TreeNodeVisitor";
  visitorMethodSuffix="";
  testTargetSubdir="Psi/Test/FSharp";
  disableReflection;
  separateHierarchies;
  visitorSuperClassName="JetBrains.ReSharper.Psi.FSharp.TreeNodeVisitorBase";
  "treeElementClassFQName"="JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement";
  "leafElementClassFQName"="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpLeafElement";
  "compositeElementClassFQName"="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpCompositeElement";
  "psiElementVisitorClassFQName"="JetBrains.ReSharper.Psi.FSharp.Tree.TreeNodeVisitor";
  "tokenTypeClassFQName"="JetBrains.ReSharper.Psi.FSharp.Parsing.FSharpTokenType";
  "unexpectedTokenClassFQName"="Parsing.UnexpectedToken";
  "syntaxErrorClassFQName"="Parsing.SyntaxError";
  "parserGenRuntimePackageName"="Parsing";
  "createTokenElementMethodFQName"="JetBrains.ReSharper.Psi.FSharp.Impl.Factory.createTokenElement";
  "visitMethodPrefix"="Visit";
  "lexerClassName"="JetBrains.ReSharper.Psi.Parsing.ILexer<int>";
  "psiClassesPrefix"="";
  "psiElementClassFQName"="JetBrains.ReSharper.Psi.FSharp.Tree.IFSharpTreeNode";
//  "semanticPsiElementClassFQName"="JetBrains.ReSharper.Psi.FSharp.Tree.IFSharpElement";
  customImplPackage="JetBrains.ReSharper.Psi.FSharp.Impl.Tree";
  customInterfacePackage="JetBrains.ReSharper.Psi.FSharp.Tree";
  "interfaceNamePrefix"="I"; 
//  "sourceInterfaceNamePrefix"="Source";
//  "sourceInterfaceNameSuffix"="Node";
  "tokenElementClassFQName"="JetBrains.ReSharper.Psi.Tree.ITokenNode";
  "customImplSuffix"="";
  "objectClassFQName"="System.Object";
  tokenBitsetThreshold=4;
  elementTypeBaseClass="JetBrains.ReSharper.Psi.FSharp.Tree.FSharpCompositeNodeType";
  parserMessagesClass="JetBrains.ReSharper.Psi.FSharp.Parsing.ParserMessages";
  generateWorkingPsi;
}

paths {  
}

abstract identifier options { 
  interfaceName = "JetBrains.ReSharper.Psi.FSharp.Tree.IFSharpIdentifier"; 
  }
  : IDENTIFIER
  ;

qualifiedNamespaceUsage options {customParseFunction; }
  :
    (
      qualifiedNamespaceUsage<QUALIFIER, Qualifier>
      DOT<DOT, Dot>
    )?
    IDENTIFIER<NAME, NameIdentifier>
  ;

accessModifier
  :
    PUBLIC_KEYWORD<MODIFIER,Modifier> |    
    PRIVATE_KEYWORD<MODIFIER,Modifier> |
    INTERNAL_KEYWORD<MODIFIER,Modifier> 
  ;

errorhandling attributeSectionList
  :
    attributeSection<ATTRIBUTE_SECTION, Sections>+
  ;

attributeSection 
  :
    LBRACK<LBRACK, LBracket>
    (
	  IDENTIFIER<NAME, NameIdentifier> // TODO
    )
    RBRACK<RBRACK, RBracket>
  ;


/////////////////////////////////////////////////////////////////////////////////////////////////
// File structure

fSharpFile options
{
  customParseFunction; noInternalParseFunction;
  stubBase="FSharpFileElement";
}
  :
    namespaceDeclaration<NAMESPACE_DECLARATION, NamespaceDeclarations>* |
	moduleDeclaration<MODULE_DECLARATION, ModuleDeclaration> 	  
  ;
 
//fSharpSignatureFile
//  :
//    
//  ;

errorhandling interface namespaceDeclaration
  :
    !(#namespaceKeyword:NAMESPACE_KEYWORD)
    (
      primaryNamespaceDeclaration[namespaceKeyword] |
	  globalNamespaceDeclaration[namespaceKeyword]
	)
  ;

primaryNamespaceDeclaration[NAMESPACE_KEYWORD namespaceKeyword]
  :
    &namespaceKeyword<NAMESPACE_KEYWORD, NamespaceKeyword>
	qualifiedNamespaceUsage<NAME, NamespaceUsage>
	moduleElement*
  ;

globalNamespaceDeclaration[NAMESPACE_KEYWORD namespaceKeyword]
  :
    &namespaceKeyword<NAMESPACE_KEYWORD, NamespaceKeyword>
	GLOBAL_KEYWORD<GLOBAL_KEYWORD, GlobalKeyword>
	moduleElement*
  ;

errorhandling interface moduleDeclaration
  :
	primaryModuleDeclaration |
	anonymousModuleDeclaration
  ;

primaryModuleDeclaration options {customParseFunction; }
  :    
	MODULE_KEYWORD<MODULE_KEYWORD, ModuleKeyword>
	(
	  qualifiedNamespaceUsage<QUALIFIER, NamespaceUsage>
	  DOT<DOT, Dot>
	)?
	IDENTIFIER<NAME, NameIdentifier>
	moduleBody<BODY, Body>
  ;

anonymousModuleDeclaration
  :    		
	moduleBody<BODY, Body>
  ;

errorhandling moduleBody
  :
    moduleElement*
  ;

errorhandling interface moduleElement
  :
    typeDeclaration 
  //just for stub  TODO    
  ;


/////////////////////////////////////////////////////////////////////////////////////////////////
// Type declarations

errorhandling typeParameterList
  :
    LESS<LANGLE, LAngle>
    LIST typeParameterDeclaration<PARAMETER, TypeParameterDeclarations> SEP COMMA<COMMA, Comma>
	typeParameterConstraintsClause<TYPE_CONSTRAINT, ConstraintsClause>?
    GREATER<RANGLE, RAngle>
  ;

typeParameterDeclaration 
  :
    attributeSectionList<ATTRIBUTES, Attributes>?	 	  
	TYPE_VARIABLE<NAME, TypeVariable>	
  ;

typeParameterUsage //? TODO: is it correct
  :
    UNDERSCORE<UNDERSCORE, Underscore> |	
	TYPE_VARIABLE<NAME, TypeVariable>
  ;

errorhandling typeParameterConstraintsClause
  :
    WHEN_KEYWORD<KEYWORD, WhenKeyword>    
    LIST typeParameterConstraint<CONSTRAINTS, Constraints> SEP COMMA<COMMA, Comma>
  ;

interface typeParameterConstraint
  :
    typeConstraint
  |
    valueConstraint
  //|   TODO: etc...
  ;

typeConstraint 
  :
    typeParameterUsage<PARAMETER, TypeParameterUsage>
	COLON_GREATER<COLON_GT, ColonGT>
    typeExpression<TYPE, TypeExpression>
  ;

valueConstraint
  :
    typeParameterUsage<PARAMETER, TypeParameterUsage>
	COLON<COLON, ColonKeyword>
    STRUCT_KEYWORD<KEYWORD, StructKeyword>
  ;

private errorhandling typeName
  :
    attributeSectionList<ATTRIBUTES, Attributes>?
    accessModifier<MODIFIER, AccessModifier>?
    IDENTIFIER<NAME, NameIdentifier>
	typeParameterList<TYPE_PARAMETERS_LIST, TypeParameterList>?
  ;

errorhandling interface typeDeclaration
  :
    abbrevTypeDeclaration
	//| TODO: etc
  ;

abbrevTypeDeclaration
  :
    TYPE_KEYWORD<KEYWORD, TypeKeyword>
    typeName
	EQUALS<EQ, Eq>
	typeExpression<TYPE, TypeExpression>
  ;

/////////////////////////////////////////////////////////////////////////////////////////////////
// Type expressions

errorhandling interface typeExpression
 :
   qualifiedTypeUsage |
   typeParameterUsage
   // TODO
 ;

 errorhandling typeArgumentList
  :
    LESS<LANGLE, LAngle>
    LIST typeExpression<TYPE, TypeArguments> SEP COMMA<COMMA, Comma>	
    GREATER<RANGLE, RAngle>
  ;

 qualifiedTypeUsage
  :
    (
       qualifiedTypeUsage<QUALIFIER, Qualifier>
      DOT<DOT, Dot>
    )?
    IDENTIFIER<NAME, NameIdentifier>
	typeArgumentList<TYPE_ARGS, TypeArgumentList>?
  ;